{"metadata":{"title":"Basic Concepts","modules":[{"name":"Rex"}],"roleHeading":"Article","role":"article"},"sections":[],"kind":"article","schemaVersion":{"patch":0,"minor":3,"major":0},"hierarchy":{"paths":[["doc:\/\/Rex\/documentation\/Rex"]]},"identifier":{"url":"doc:\/\/Rex\/documentation\/Rex\/BasicConcepts","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn the fundamental concepts that make up the Swift-Rex architecture."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"Swift-Rex is built around a few core concepts that work together to provide a predictable and manageable state management system. Understanding these concepts is key to building effective applications with Swift-Rex."}],"type":"paragraph"},{"level":2,"anchor":"State","type":"heading","text":"State"},{"inlineContent":[{"type":"text","text":"State represents the current condition of your application at any point in time. It’s the single source of truth for your app’s data."}],"type":"paragraph"},{"level":3,"anchor":"Key-Characteristics","type":"heading","text":"Key Characteristics"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Immutable","type":"text"}]},{"type":"text","text":": State should never be modified directly"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Serializable"}]},{"type":"text","text":": State can be saved and restored"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Predictable"}],"type":"strong"},{"text":": Given the same inputs, state changes are always the same","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Observable"}],"type":"strong"},{"type":"text","text":": Changes to state trigger UI updates"}]}]}]},{"level":3,"anchor":"Example","type":"heading","text":"Example"},{"code":["struct AppState: StateType {","    var count: Int = 0","    var isLoading: Bool = false","    var errorMessage: String? = nil","    var lastUpdated: Date = Date()","    var user: User?","}"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"Actions","type":"heading","text":"Actions"},{"inlineContent":[{"type":"text","text":"Actions describe what happened in your application. They are the only way to change state."}],"type":"paragraph"},{"level":3,"anchor":"Key-Characteristics","type":"heading","text":"Key Characteristics"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Descriptive","type":"text"}],"type":"strong"},{"text":": Actions clearly describe what happened","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Immutable"}],"type":"strong"},{"text":": Actions contain only the data needed to describe the event","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Serializable"}]},{"type":"text","text":": Actions can be logged and replayed"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Type-Safe","type":"text"}]},{"type":"text","text":": Actions are strongly typed"}],"type":"paragraph"}]}]},{"level":3,"anchor":"Example","type":"heading","text":"Example"},{"code":["enum AppAction: ActionType {","    \/\/ User interactions","    case increment","    case decrement","    case setCount(Int)","    ","    \/\/ Async operations","    case loadUser","    case userLoaded(User)","    case loadFailed(String)","    ","    \/\/ UI state","    case showLoading","    case hideLoading","    case setError(String?)","}"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"Reducers","type":"heading","text":"Reducers"},{"inlineContent":[{"type":"text","text":"Reducers are pure functions that take the current state and an action, then return a new state and any effects."}],"type":"paragraph"},{"level":3,"anchor":"Key-Principles","type":"heading","text":"Key Principles"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Pure Functions","type":"text"}],"type":"strong"},{"type":"text","text":": Reducers have no side effects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Predictable"}],"type":"strong"},{"text":": Same state + action always produces same result","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Immutable"}]},{"text":": Always return new state, never modify existing state","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Composable"}]},{"type":"text","text":": Reducers can be combined and split"}]}]}]},{"level":3,"anchor":"Example","type":"heading","text":"Example"},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .increment:","            state.count += 1","            state.lastUpdated = Date()","            return [.none]","            ","        case .loadUser:","            state.isLoading = true","            state.errorMessage = nil","            return [","                Effect { emitter in","                    let user = try await UserService.fetchUser()","                    await emitter.send(.userLoaded(user))","                }","            ]","            ","        case .userLoaded(let user):","            state.user = user","            state.isLoading = false","            state.lastUpdated = Date()","            return [.none]","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"Store","type":"heading","text":"Store"},{"inlineContent":[{"type":"text","text":"The store is the central coordinator that holds the state, dispatches actions, and manages effects."}],"type":"paragraph"},{"level":3,"anchor":"Responsibilities","type":"heading","text":"Responsibilities"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"State Management","type":"text"}]},{"text":": Holds the current application state","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Action Dispatching","type":"text"}],"type":"strong"},{"type":"text","text":": Processes actions through the reducer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Effect Execution","type":"text"}],"type":"strong"},{"text":": Runs side effects and async operations","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Subscription Management"}]},{"type":"text","text":": Notifies subscribers of state changes"}]}]}]},{"level":3,"anchor":"Example","type":"heading","text":"Example"},{"code":["let store = Store(","    initialState: AppState(),","    reducer: AppReducer()",") {","    LoggingMiddleware()","}","","\/\/ Subscribe to state changes","store.subscribe { newState in","    print(\"State updated: \\(newState)\")","}","","\/\/ Dispatch actions","store.dispatch(.increment)","store.dispatch(.loadUser)"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"Effects","type":"heading","text":"Effects"},{"inlineContent":[{"text":"Effects represent side effects or asynchronous operations that can’t be performed in the reducer.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"Use-Cases","type":"heading","text":"Use Cases"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Network Requests"}],"type":"strong"},{"type":"text","text":": API calls and data fetching"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"File Operations"}]},{"type":"text","text":": Reading and writing files"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Timers","type":"text"}],"type":"strong"},{"text":": Scheduled operations","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Device Services"}]},{"type":"text","text":": Camera, location, etc."}]}]}]},{"level":3,"anchor":"Example","type":"heading","text":"Example"},{"code":["\/\/ Network request effect","Effect { emitter in","    let data = try await URLSession.shared.data(from: url)","    let response = try JSONDecoder().decode(User.self, from: data.0)","    await emitter.send(.userLoaded(response))","}","","\/\/ Timer effect","Effect { emitter in","    for await _ in Timer.publish(every: 1, on: .main, in: .common).autoconnect() {","        await emitter.send(.timerTick)","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"anchor":"Data-Flow","type":"heading","text":"Data Flow"},{"inlineContent":[{"type":"text","text":"Swift-Rex follows a unidirectional data flow:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"User Interaction","type":"text"}],"type":"strong"},{"text":": User performs an action (e.g., taps a button)","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Action Dispatch"}]},{"type":"text","text":": An action is dispatched to the store"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Middleware Processing"}]},{"text":": Actions pass through middleware (logging, analytics, etc.)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Reducer Processing","type":"text"}]},{"type":"text","text":": The reducer processes the action and updates state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Effect Execution"}],"type":"strong"},{"text":": Any effects returned by the reducer are executed","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"State Update","type":"text"}]},{"type":"text","text":": The store updates its state"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"UI Update","type":"text"}]},{"type":"text","text":": Subscribers are notified and the UI updates"}],"type":"paragraph"}]}]},{"level":3,"anchor":"Visual-Flow","type":"heading","text":"Visual Flow"},{"code":["User Action → Action Dispatch → Middleware → Reducer → Effects → State Update → UI Update"],"type":"codeListing","syntax":null},{"level":2,"anchor":"Benefits","type":"heading","text":"Benefits"},{"inlineContent":[{"type":"text","text":"This architecture provides several key benefits:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Predictability"}]},{"text":": State changes are predictable and traceable","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Debugging"}]},{"type":"text","text":": Easy to debug with action logging and time travel"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Testing","type":"text"}]},{"type":"text","text":": Pure functions are easy to test"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Performance"}],"type":"strong"},{"text":": Efficient updates and minimal re-renders","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Scalability","type":"text"}]},{"type":"text","text":": Architecture scales well with app complexity"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Maintainability","type":"text"}],"type":"strong"},{"text":": Clear separation of concerns","type":"text"}]}]}]},{"level":2,"anchor":"Next-Steps","type":"heading","text":"Next Steps"},{"inlineContent":[{"text":"Now that you understand the basic concepts, explore:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","isActive":true},{"type":"text","text":" - Learn about state management patterns"}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","isActive":true},{"type":"text","text":" - Deep dive into the Store"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","type":"reference","isActive":true},{"text":" - Learn about Reducer patterns","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect"},{"type":"text","text":" - Understand Effects and side effects"}],"type":"paragraph"}]}]}]}],"variants":[{"paths":["\/documentation\/rex\/basicconcepts"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://Rex/documentation/Rex/Store":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[],"role":"symbol","kind":"symbol","url":"\/documentation\/rex\/store","navigatorTitle":[{"kind":"identifier","text":"Store"}],"title":"Store","type":"topic","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store"},"doc://Rex/documentation/Rex/Effect":{"title":"Effect","role":"symbol","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"type":"topic","abstract":[{"text":"A struct that represents a side effect that can be executed by the store.","type":"text"}],"kind":"symbol","identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Effect","kind":"identifier"}],"url":"\/documentation\/rex\/effect"},"doc://Rex/documentation/Rex/StateManagement":{"url":"\/documentation\/rex\/statemanagement","kind":"article","title":"State Management","type":"topic","abstract":[{"type":"text","text":"Learn how to effectively manage application state with Swift-Rex."}],"identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","role":"article"},"doc://Rex/documentation/Rex":{"role":"collection","type":"topic","title":"Rex","abstract":[],"kind":"symbol","identifier":"doc:\/\/Rex\/documentation\/Rex","url":"\/documentation\/rex"},"doc://Rex/documentation/Rex/Reducer":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/rex\/reducer","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"kind":"symbol","title":"Reducer","identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","type":"topic","abstract":[{"text":"A protocol that defines the core logic for transforming state based on actions.","type":"text"}],"role":"symbol"}}}