{"sections":[],"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"text":"Learn the fundamental concepts that make up the Swift-Rex architecture.","type":"text"}],"metadata":{"title":"Basic Concepts","modules":[{"name":"Rex"}],"role":"article","roleHeading":"Article"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/rex\/basicconcepts"]}],"identifier":{"url":"doc:\/\/Rex\/documentation\/Rex\/BasicConcepts","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"inlineContent":[{"text":"Swift-Rex is built around a few core concepts that work together to provide a predictable and manageable state management system. Understanding these concepts is key to building effective applications with Swift-Rex.","type":"text"}],"type":"paragraph"},{"text":"State","anchor":"State","level":2,"type":"heading"},{"inlineContent":[{"text":"State represents the current condition of your application at any point in time. It’s the single source of truth for your app’s data.","type":"text"}],"type":"paragraph"},{"text":"Key Characteristics","anchor":"Key-Characteristics","level":3,"type":"heading"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Immutable"}],"type":"strong"},{"type":"text","text":": State should never be modified directly"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Serializable"}],"type":"strong"},{"type":"text","text":": State can be saved and restored"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Predictable","type":"text"}]},{"text":": Given the same inputs, state changes are always the same","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Observable","type":"text"}]},{"type":"text","text":": Changes to state trigger UI updates"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Example","anchor":"Example","level":3,"type":"heading"},{"code":["struct AppState: StateType {","    var count: Int = 0","    var isLoading: Bool = false","    var errorMessage: String? = nil","    var lastUpdated: Date = Date()","    var user: User?","}"],"syntax":"swift","type":"codeListing"},{"text":"Actions","anchor":"Actions","level":2,"type":"heading"},{"inlineContent":[{"text":"Actions describe what happened in your application. They are the only way to change state.","type":"text"}],"type":"paragraph"},{"text":"Key Characteristics","anchor":"Key-Characteristics","level":3,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Descriptive"}]},{"type":"text","text":": Actions clearly describe what happened"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Immutable","type":"text"}]},{"text":": Actions contain only the data needed to describe the event","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Serializable","type":"text"}]},{"type":"text","text":": Actions can be logged and replayed"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Type-Safe","type":"text"}],"type":"strong"},{"type":"text","text":": Actions are strongly typed"}]}]}],"type":"unorderedList"},{"text":"Example","anchor":"Example","level":3,"type":"heading"},{"code":["enum AppAction: ActionType {","    \/\/ User interactions","    case increment","    case decrement","    case setCount(Int)","    ","    \/\/ Async operations","    case loadUser","    case userLoaded(User)","    case loadFailed(String)","    ","    \/\/ UI state","    case showLoading","    case hideLoading","    case setError(String?)","}"],"syntax":"swift","type":"codeListing"},{"text":"Reducers","anchor":"Reducers","level":2,"type":"heading"},{"inlineContent":[{"text":"Reducers are pure functions that take the current state and an action, then return a new state and any effects.","type":"text"}],"type":"paragraph"},{"text":"Key Principles","anchor":"Key-Principles","level":3,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Pure Functions"}]},{"type":"text","text":": Reducers have no side effects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Predictable","type":"text"}],"type":"strong"},{"text":": Same state + action always produces same result","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Immutable","type":"text"}]},{"text":": Always return new state, never modify existing state","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Composable"}],"type":"strong"},{"text":": Reducers can be combined and split","type":"text"}]}]}],"type":"unorderedList"},{"text":"Example","anchor":"Example","level":3,"type":"heading"},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .increment:","            state.count += 1","            state.lastUpdated = Date()","            return [.none]","            ","        case .loadUser:","            state.isLoading = true","            state.errorMessage = nil","            return [","                Effect { emitter in","                    let user = try await UserService.fetchUser()","                    await emitter.send(.userLoaded(user))","                }","            ]","            ","        case .userLoaded(let user):","            state.user = user","            state.isLoading = false","            state.lastUpdated = Date()","            return [.none]","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Store","anchor":"Store","level":2,"type":"heading"},{"inlineContent":[{"text":"The store is the central coordinator that holds the state, dispatches actions, and manages effects.","type":"text"}],"type":"paragraph"},{"text":"Responsibilities","anchor":"Responsibilities","level":3,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State Management"}]},{"type":"text","text":": Holds the current application state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Action Dispatching"}],"type":"strong"},{"text":": Processes actions through the reducer","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Effect Execution","type":"text"}]},{"type":"text","text":": Runs side effects and async operations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Subscription Management"}],"type":"strong"},{"text":": Notifies subscribers of state changes","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Example","anchor":"Example","level":3,"type":"heading"},{"code":["let store = Store(","    initialState: AppState(),","    reducer: AppReducer()",") {","    LoggingMiddleware()","}","","\/\/ Subscribe to state changes","store.subscribe { newState in","    print(\"State updated: \\(newState)\")","}","","\/\/ Dispatch actions","store.dispatch(.increment)","store.dispatch(.loadUser)"],"syntax":"swift","type":"codeListing"},{"text":"Effects","anchor":"Effects","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Effects represent side effects or asynchronous operations that can’t be performed in the reducer."}],"type":"paragraph"},{"text":"Use Cases","anchor":"Use-Cases","level":3,"type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Network Requests"}]},{"type":"text","text":": API calls and data fetching"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"File Operations","type":"text"}],"type":"strong"},{"type":"text","text":": Reading and writing files"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Timers","type":"text"}]},{"text":": Scheduled operations","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Device Services","type":"text"}]},{"type":"text","text":": Camera, location, etc."}]}]}],"type":"unorderedList"},{"text":"Example","anchor":"Example","level":3,"type":"heading"},{"code":["\/\/ Network request effect","Effect { emitter in","    let data = try await URLSession.shared.data(from: url)","    let response = try JSONDecoder().decode(User.self, from: data.0)","    await emitter.send(.userLoaded(response))","}","","\/\/ Timer effect","Effect { emitter in","    for await _ in Timer.publish(every: 1, on: .main, in: .common).autoconnect() {","        await emitter.send(.timerTick)","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Data Flow","anchor":"Data-Flow","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Swift-Rex follows a unidirectional data flow:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"User Interaction","type":"text"}],"type":"strong"},{"type":"text","text":": User performs an action (e.g., taps a button)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Action Dispatch"}],"type":"strong"},{"type":"text","text":": An action is dispatched to the store"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Middleware Processing"}]},{"type":"text","text":": Actions pass through middleware (logging, analytics, etc.)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Reducer Processing","type":"text"}]},{"type":"text","text":": The reducer processes the action and updates state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Effect Execution"}],"type":"strong"},{"text":": Any effects returned by the reducer are executed","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State Update"}]},{"text":": The store updates its state","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"UI Update","type":"text"}]},{"text":": Subscribers are notified and the UI updates","type":"text"}]}]}],"type":"orderedList"},{"text":"Visual Flow","anchor":"Visual-Flow","level":3,"type":"heading"},{"code":["User Action → Action Dispatch → Middleware → Reducer → Effects → State Update → UI Update"],"syntax":null,"type":"codeListing"},{"text":"Benefits","anchor":"Benefits","level":2,"type":"heading"},{"inlineContent":[{"text":"This architecture provides several key benefits:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Predictability"}],"type":"strong"},{"type":"text","text":": State changes are predictable and traceable"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Debugging","type":"text"}]},{"type":"text","text":": Easy to debug with action logging and time travel"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Testing","type":"text"}],"type":"strong"},{"type":"text","text":": Pure functions are easy to test"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Performance"}],"type":"strong"},{"text":": Efficient updates and minimal re-renders","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Scalability","type":"text"}],"type":"strong"},{"type":"text","text":": Architecture scales well with app complexity"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Maintainability"}]},{"type":"text","text":": Clear separation of concerns"}]}]}],"type":"unorderedList"},{"text":"Next Steps","anchor":"Next-Steps","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Now that you understand the basic concepts, explore:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","isActive":true},{"type":"text","text":" - Learn about state management patterns"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","type":"reference","isActive":true},{"text":" - Deep dive into the Store","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","isActive":true,"type":"reference"},{"text":" - Learn about Reducer patterns","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","isActive":true},{"type":"text","text":" - Understand Effects and side effects"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"hierarchy":{"paths":[["doc:\/\/Rex\/documentation\/Rex"]]},"references":{"doc://Rex/documentation/Rex/Store":{"abstract":[],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"role":"symbol","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","navigatorTitle":[{"kind":"identifier","text":"Store"}],"kind":"symbol","type":"topic","title":"Store","url":"\/documentation\/rex\/store"},"doc://Rex/documentation/Rex/Effect":{"url":"\/documentation\/rex\/effect","identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","title":"Effect","abstract":[{"type":"text","text":"A struct that represents a side effect that can be executed by the store."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"kind":"symbol","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Effect"}]},"doc://Rex/documentation/Rex/Reducer":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/rex\/reducer","kind":"symbol","title":"Reducer","identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"type":"topic","abstract":[{"text":"A protocol that defines the core logic for transforming state based on actions.","type":"text"}],"role":"symbol"},"doc://Rex/documentation/Rex":{"role":"collection","type":"topic","abstract":[],"url":"\/documentation\/rex","identifier":"doc:\/\/Rex\/documentation\/Rex","kind":"symbol","title":"Rex"},"doc://Rex/documentation/Rex/StateManagement":{"title":"State Management","identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","abstract":[{"text":"Learn how to effectively manage application state with Swift-Rex.","type":"text"}],"type":"topic","role":"article","kind":"article","url":"\/documentation\/rex\/statemanagement"}}}