{"hierarchy":{"paths":[["doc:\/\/Rex\/documentation\/Rex"]]},"kind":"article","primaryContentSections":[{"content":[{"anchor":"Overview","text":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"State management is the core of any Swift-Rex application. Understanding how to structure and manage your state effectively is crucial for building maintainable and scalable applications.","type":"text"}]},{"anchor":"State-Structure","text":"State Structure","level":2,"type":"heading"},{"anchor":"Single-State-Tree","text":"Single State Tree","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Swift-Rex uses a single state tree that represents the entire state of your application. This makes it easy to track changes and debug issues.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct AppState: StateType {","    \/\/ User state","    var user: User?","    var isAuthenticated: Bool = false","","    \/\/ UI state","    var isLoading: Bool = false","    var errorMessage: String? = nil","","    \/\/ Feature state","    var counter: CounterState = CounterState()","    var todo: TodoState = TodoState()","    var settings: SettingsState = SettingsState()","","    \/\/ App state","    var lastUpdated: Date = Date()","}"]},{"anchor":"Nested-State","text":"Nested State","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Break down your state into smaller, focused pieces:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct CounterState {","    var count: Int = 0","    var history: [Int] = []","}","","struct TodoState {","    var todos: [Todo] = []","    var filter: TodoFilter = .all","    var isLoading: Bool = false","}","","struct SettingsState {","    var theme: Theme = .light","    var notifications: Bool = true","    var language: Language = .english","}"]},{"anchor":"State-Updates","text":"State Updates","level":2,"type":"heading"},{"anchor":"Immutable-Updates","text":"Immutable Updates","level":3,"type":"heading"},{"inlineContent":[{"text":"Always create new state rather than modifying existing state:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Wrong - Direct mutation","state.count += 1","","\/\/ ✅ Correct - Create new state","state.count = state.count + 1"]},{"level":3,"anchor":"Batch-Updates","type":"heading","text":"Batch Updates"},{"inlineContent":[{"text":"When updating multiple properties, do it in a single action:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["case .userLoggedIn(let user):","    state.user = user","    state.isAuthenticated = true","    state.errorMessage = nil","    state.lastUpdated = Date()","    return [.none]"]},{"level":2,"anchor":"State-Normalization","type":"heading","text":"State Normalization"},{"level":3,"anchor":"Normalized-Data","type":"heading","text":"Normalized Data"},{"inlineContent":[{"type":"text","text":"Store related data in a normalized structure for better performance:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppState: StateType {","    \/\/ Normalized entities","    var users: [String: User] = [:]","    var posts: [String: Post] = [:]","    var comments: [String: Comment] = [:]","","    \/\/ References","    var currentUserId: String?","    var selectedPostId: String?","","    \/\/ UI state","    var isLoading: Bool = false","    var errorMessage: String? = nil","}"]},{"level":3,"anchor":"Benefits-of-Normalization","type":"heading","text":"Benefits of Normalization"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Performance","type":"text"}]},{"type":"text","text":": Faster lookups and updates"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Consistency","type":"text"}]},{"text":": Single source of truth for each entity","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Memory"}],"type":"strong"},{"text":": Reduced memory usage","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Updates"}],"type":"strong"},{"type":"text","text":": Easier to update related data"}],"type":"paragraph"}]}]},{"level":2,"anchor":"State-Composition","type":"heading","text":"State Composition"},{"level":3,"anchor":"Combining-Reducers","type":"heading","text":"Combining Reducers"},{"inlineContent":[{"type":"text","text":"Split your reducer into smaller, focused reducers:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case let .counter(action):","            return counterReducer.reduce(state: &state.counter, action: action)","","        case let .todo(action):","            return todoReducer.reduce(state: &state.todo, action: action)","","        case let .settings(action):","            return settingsReducer.reduce(state: &state.settings, action: action)","","        case .userLoggedIn(let user):","            state.user = user","            state.isAuthenticated = true","            return [.none]","        }","    }","}"]},{"level":3,"anchor":"Action-Composition","type":"heading","text":"Action Composition"},{"inlineContent":[{"text":"Use associated values to compose actions:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["enum AppAction: ActionType {","    case counter(CounterAction)","    case todo(TodoAction)","    case settings(SettingsAction)","    case user(UserAction)","}","","enum CounterAction: ActionType {","    case increment","    case decrement","    case reset","}","","enum TodoAction: ActionType {","    case add(String)","    case remove(String)","    case toggle(String)","    case setFilter(TodoFilter)","}"]},{"level":2,"anchor":"State-Persistence","type":"heading","text":"State Persistence"},{"level":3,"anchor":"Saving-State","type":"heading","text":"Saving State"},{"inlineContent":[{"type":"text","text":"Persist important state to disk:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .userLoggedIn(let user):","            state.user = user","            state.isAuthenticated = true","            return [","                Effect { emitter in","                    \/\/ Save user to disk","                    try await UserDefaults.standard.setValue(","                        user.id,","                        forKey: \"currentUserId\"","                    )","                    await emitter.send(.userSaved)","                }","            ]","        }","    }","}"]},{"level":3,"anchor":"Loading-State","type":"heading","text":"Loading State"},{"inlineContent":[{"text":"Load persisted state on app launch:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .loadPersistedState:","            return [","                Effect { emitter in","                    if let userId = UserDefaults.standard.string(forKey: \"currentUserId\") {","                        let user = try await UserService.fetchUser(id: userId)","                        await emitter.send(.userLoaded(user))","                    }","                }","            ]","        }","    }","}"]},{"level":2,"anchor":"State-Validation","type":"heading","text":"State Validation"},{"level":3,"anchor":"Input-Validation","type":"heading","text":"Input Validation"},{"inlineContent":[{"type":"text","text":"Validate state changes in your reducer:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["case .setCount(let count):","    guard count >= 0 else {","        state.errorMessage = \"Count cannot be negative\"","        return [.none]","    }","    state.count = count","    state.lastUpdated = Date()","    return [.none]"]},{"level":3,"anchor":"State-Constraints","type":"heading","text":"State Constraints"},{"inlineContent":[{"text":"Enforce business rules in your state:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppState: StateType {","    var count: Int = 0 {","        didSet {","            \/\/ Ensure count never goes below 0","            if count < 0 {","                count = 0","            }","        }","    }","}"]},{"level":2,"anchor":"Performance-Optimization","type":"heading","text":"Performance Optimization"},{"level":3,"anchor":"Selective-Updates","type":"heading","text":"Selective Updates"},{"inlineContent":[{"type":"text","text":"Only update what has changed:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["case .updateUserProfile(let profile):","    \/\/ Only update if profile actually changed","    if state.user?.profile != profile {","        state.user?.profile = profile","        state.lastUpdated = Date()","    }","    return [.none]"]},{"level":3,"anchor":"Computed-Properties","type":"heading","text":"Computed Properties"},{"inlineContent":[{"text":"Use computed properties for derived state:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension AppState {","    var completedTodos: [Todo] {","        todos.filter { $0.isCompleted }","    }","","    var incompleteTodos: [Todo] {","        todos.filter { !$0.isCompleted }","    }","","    var todoCount: Int {","        todos.count","    }","}"]},{"level":2,"anchor":"Best-Practices","type":"heading","text":"Best Practices"},{"level":3,"anchor":"1-Keep-State-Minimal","type":"heading","text":"1. Keep State Minimal"},{"inlineContent":[{"text":"Only store what you need:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Don't store derived data","struct AppState {","    var todos: [Todo] = []","    var completedTodos: [Todo] = [] \/\/ Redundant","}","","\/\/ ✅ Store only source data","struct AppState {","    var todos: [Todo] = []","}"]},{"level":3,"anchor":"2-Use-Descriptive-Names","type":"heading","text":"2. Use Descriptive Names"},{"inlineContent":[{"text":"Make your state properties self-documenting:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Unclear","var flag: Bool = false","","\/\/ ✅ Clear","var isUserLoggedIn: Bool = false"]},{"level":3,"anchor":"3-Group-Related-State","type":"heading","text":"3. Group Related State"},{"inlineContent":[{"type":"text","text":"Keep related properties together:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct AppState {","    \/\/ Authentication","    var user: User?","    var isAuthenticated: Bool = false","    var authToken: String?","","    \/\/ UI State","    var isLoading: Bool = false","    var errorMessage: String? = nil","    var currentTab: Tab = .home","","    \/\/ Feature State","    var counter: CounterState = CounterState()","    var todo: TodoState = TodoState()","}"]},{"level":3,"anchor":"4-Handle-Loading-States","type":"heading","text":"4. Handle Loading States"},{"inlineContent":[{"type":"text","text":"Always track loading states for async operations:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["case .loadUser:","    state.isLoading = true","    state.errorMessage = nil","    return [","        Effect { emitter in","            let user = try await UserService.fetchUser()","            await emitter.send(.userLoaded(user))","        }","    ]"]},{"level":3,"anchor":"5-Error-Handling","type":"heading","text":"5. Error Handling"},{"inlineContent":[{"type":"text","text":"Provide meaningful error messages:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["case .loadUserFailed(let error):","    state.isLoading = false","    state.errorMessage = \"Failed to load user: \\(error.localizedDescription)\"","    return [.none]"]},{"level":2,"anchor":"Next-Steps","type":"heading","text":"Next Steps"},{"inlineContent":[{"type":"text","text":"Now that you understand state management, explore:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","isActive":true,"type":"reference"},{"type":"text","text":" - Learn about the Store implementation"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","isActive":true},{"text":" - Understand Reducer patterns","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","type":"reference"},{"text":" - Handle side effects","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"doc:BestPractices"},{"type":"text","text":" - Advanced patterns and tips"}],"type":"paragraph"}]}]}],"kind":"content"}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/rex\/statemanagement"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"type":"text","text":"Learn how to effectively manage application state with Swift-Rex."}],"identifier":{"url":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","interfaceLanguage":"swift"},"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"Rex"}],"title":"State Management"},"references":{"doc://Rex/documentation/Rex/Reducer":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/rex\/reducer","kind":"symbol","title":"Reducer","identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"type":"topic","abstract":[{"text":"A protocol that defines the core logic for transforming state based on actions.","type":"text"}],"role":"symbol"},"doc://Rex/documentation/Rex":{"role":"collection","type":"topic","abstract":[],"url":"\/documentation\/rex","identifier":"doc:\/\/Rex\/documentation\/Rex","kind":"symbol","title":"Rex"},"doc://Rex/documentation/Rex/Effect":{"url":"\/documentation\/rex\/effect","identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","title":"Effect","abstract":[{"type":"text","text":"A struct that represents a side effect that can be executed by the store."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"kind":"symbol","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Effect"}]},"doc://Rex/documentation/Rex/Store":{"abstract":[],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"role":"symbol","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","navigatorTitle":[{"kind":"identifier","text":"Store"}],"kind":"symbol","type":"topic","title":"Store","url":"\/documentation\/rex\/store"}}}