{"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"identifier":{"url":"doc:\/\/Rex\/documentation\/Rex\/BasicConcepts","interfaceLanguage":"swift"},"kind":"article","abstract":[{"text":"Learn the fundamental concepts that make up the Swift-Rex architecture.","type":"text"}],"metadata":{"title":"Basic Concepts","roleHeading":"Article","modules":[{"name":"Rex"}],"role":"article"},"hierarchy":{"paths":[["doc:\/\/Rex\/documentation\/Rex"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift-Rex is built around a few core concepts that work together to provide a predictable and manageable state management system. Understanding these concepts is key to building effective applications with Swift-Rex."}]},{"level":2,"text":"State","type":"heading","anchor":"State"},{"type":"paragraph","inlineContent":[{"text":"State represents the current condition of your application at any point in time. It’s the single source of truth for your app’s data.","type":"text"}]},{"level":3,"text":"Key Characteristics","type":"heading","anchor":"Key-Characteristics"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Immutable","type":"text"}]},{"type":"text","text":": State should never be modified directly"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Serializable","type":"text"}],"type":"strong"},{"type":"text","text":": State can be saved and restored"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Predictable"}],"type":"strong"},{"text":": Given the same inputs, state changes are always the same","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Observable","type":"text"}]},{"type":"text","text":": Changes to state trigger UI updates"}]}]}]},{"level":3,"text":"Example","type":"heading","anchor":"Example"},{"code":["struct AppState: StateType {","    var count: Int = 0","    var isLoading: Bool = false","    var errorMessage: String? = nil","    var lastUpdated: Date = Date()","    var user: User?","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Actions","type":"heading","anchor":"Actions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actions describe what happened in your application. They are the only way to change state."}]},{"level":3,"text":"Key Characteristics","type":"heading","anchor":"Key-Characteristics"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Descriptive","type":"text"}]},{"type":"text","text":": Actions clearly describe what happened"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Immutable"}],"type":"strong"},{"type":"text","text":": Actions contain only the data needed to describe the event"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Serializable","type":"text"}]},{"type":"text","text":": Actions can be logged and replayed"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Type-Safe","type":"text"}],"type":"strong"},{"text":": Actions are strongly typed","type":"text"}]}]}]},{"level":3,"text":"Example","type":"heading","anchor":"Example"},{"code":["enum AppAction: ActionType {","    \/\/ User interactions","    case increment","    case decrement","    case setCount(Int)","    ","    \/\/ Async operations","    case loadUser","    case userLoaded(User)","    case loadFailed(String)","    ","    \/\/ UI state","    case showLoading","    case hideLoading","    case setError(String?)","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Reducers","type":"heading","anchor":"Reducers"},{"type":"paragraph","inlineContent":[{"text":"Reducers are pure functions that take the current state and an action, then return a new state and any effects.","type":"text"}]},{"level":3,"text":"Key Principles","type":"heading","anchor":"Key-Principles"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Pure Functions","type":"text"}]},{"type":"text","text":": Reducers have no side effects"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Predictable"}],"type":"strong"},{"text":": Same state + action always produces same result","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Immutable","type":"text"}],"type":"strong"},{"text":": Always return new state, never modify existing state","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Composable","type":"text"}]},{"type":"text","text":": Reducers can be combined and split"}],"type":"paragraph"}]}]},{"level":3,"text":"Example","type":"heading","anchor":"Example"},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .increment:","            state.count += 1","            state.lastUpdated = Date()","            return [.none]","            ","        case .loadUser:","            state.isLoading = true","            state.errorMessage = nil","            return [","                Effect { emitter in","                    let user = try await UserService.fetchUser()","                    await emitter.send(.userLoaded(user))","                }","            ]","            ","        case .userLoaded(let user):","            state.user = user","            state.isLoading = false","            state.lastUpdated = Date()","            return [.none]","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Store","type":"heading","anchor":"Store"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The store is the central coordinator that holds the state, dispatches actions, and manages effects."}]},{"level":3,"text":"Responsibilities","type":"heading","anchor":"Responsibilities"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State Management"}]},{"type":"text","text":": Holds the current application state"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Action Dispatching","type":"text"}],"type":"strong"},{"type":"text","text":": Processes actions through the reducer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Effect Execution","type":"text"}]},{"type":"text","text":": Runs side effects and async operations"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Subscription Management","type":"text"}],"type":"strong"},{"text":": Notifies subscribers of state changes","type":"text"}]}]}]},{"level":3,"text":"Example","type":"heading","anchor":"Example"},{"code":["let store = Store(","    initialState: AppState(),","    reducer: AppReducer()",") {","    LoggingMiddleware()","}","","\/\/ Subscribe to state changes","store.subscribe { newState in","    print(\"State updated: \\(newState)\")","}","","\/\/ Dispatch actions","store.dispatch(.increment)","store.dispatch(.loadUser)"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Effects","type":"heading","anchor":"Effects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Effects represent side effects or asynchronous operations that can’t be performed in the reducer."}]},{"level":3,"text":"Use Cases","type":"heading","anchor":"Use-Cases"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Network Requests"}]},{"text":": API calls and data fetching","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"File Operations","type":"text"}]},{"text":": Reading and writing files","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Timers"}],"type":"strong"},{"text":": Scheduled operations","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Device Services","type":"text"}],"type":"strong"},{"type":"text","text":": Camera, location, etc."}],"type":"paragraph"}]}]},{"level":3,"text":"Example","type":"heading","anchor":"Example"},{"code":["\/\/ Network request effect","Effect { emitter in","    let data = try await URLSession.shared.data(from: url)","    let response = try JSONDecoder().decode(User.self, from: data.0)","    await emitter.send(.userLoaded(response))","}","","\/\/ Timer effect","Effect { emitter in","    for await _ in Timer.publish(every: 1, on: .main, in: .common).autoconnect() {","        await emitter.send(.timerTick)","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Data Flow","type":"heading","anchor":"Data-Flow"},{"type":"paragraph","inlineContent":[{"text":"Swift-Rex follows a unidirectional data flow:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"User Interaction","type":"text"}]},{"text":": User performs an action (e.g., taps a button)","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Action Dispatch"}]},{"type":"text","text":": An action is dispatched to the store"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Middleware Processing"}]},{"type":"text","text":": Actions pass through middleware (logging, analytics, etc.)"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Reducer Processing","type":"text"}],"type":"strong"},{"text":": The reducer processes the action and updates state","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Effect Execution"}]},{"type":"text","text":": Any effects returned by the reducer are executed"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"State Update","type":"text"}]},{"type":"text","text":": The store updates its state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"UI Update"}],"type":"strong"},{"text":": Subscribers are notified and the UI updates","type":"text"}]}]}]},{"level":3,"text":"Visual Flow","type":"heading","anchor":"Visual-Flow"},{"code":["User Action → Action Dispatch → Middleware → Reducer → Effects → State Update → UI Update"],"type":"codeListing","syntax":null},{"level":2,"text":"Benefits","type":"heading","anchor":"Benefits"},{"type":"paragraph","inlineContent":[{"text":"This architecture provides several key benefits:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Predictability"}],"type":"strong"},{"text":": State changes are predictable and traceable","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Debugging","type":"text"}]},{"type":"text","text":": Easy to debug with action logging and time travel"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Testing"}],"type":"strong"},{"text":": Pure functions are easy to test","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Performance"}],"type":"strong"},{"text":": Efficient updates and minimal re-renders","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Scalability"}]},{"text":": Architecture scales well with app complexity","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Maintainability"}]},{"type":"text","text":": Clear separation of concerns"}],"type":"paragraph"}]}]},{"level":2,"text":"Next Steps","type":"heading","anchor":"Next-Steps"},{"type":"paragraph","inlineContent":[{"text":"Now that you understand the basic concepts, explore:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement"},{"type":"text","text":" - Learn about state management patterns"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","isActive":true},{"type":"text","text":" - Deep dive into the Store"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","isActive":true,"type":"reference"},{"text":" - Learn about Reducer patterns","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","type":"reference","isActive":true},{"text":" - Understand Effects and side effects","type":"text"}]}]}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/rex\/basicconcepts"]}],"references":{"doc://Rex/documentation/Rex/Effect":{"abstract":[{"text":"A struct that represents a side effect that can be executed by the store.","type":"text"}],"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"type":"topic","title":"Effect","url":"\/documentation\/rex\/effect","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Effect","kind":"identifier"}]},"doc://Rex/documentation/Rex/StateManagement":{"url":"\/documentation\/rex\/statemanagement","kind":"article","abstract":[{"text":"Learn how to effectively manage application state with Swift-Rex.","type":"text"}],"role":"article","identifier":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","type":"topic","title":"State Management"},"doc://Rex/documentation/Rex/Reducer":{"type":"topic","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","kind":"symbol","abstract":[{"text":"A protocol that defines the core logic for transforming state based on actions.","type":"text"}],"title":"Reducer","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/rex\/reducer"},"doc://Rex/documentation/Rex":{"abstract":[],"identifier":"doc:\/\/Rex\/documentation\/Rex","type":"topic","kind":"symbol","url":"\/documentation\/rex","title":"Rex","role":"collection"},"doc://Rex/documentation/Rex/Store":{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","url":"\/documentation\/rex\/store","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Store","kind":"identifier"}],"navigatorTitle":[{"text":"Store","kind":"identifier"}],"title":"Store","role":"symbol","kind":"symbol","abstract":[]}}}