{"primaryContentSections":[{"content":[{"anchor":"Overview","text":"Overview","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"State management is the core of any Swift-Rex application. Understanding how to structure and manage your state effectively is crucial for building maintainable and scalable applications."}],"type":"paragraph"},{"anchor":"State-Structure","text":"State Structure","type":"heading","level":2},{"anchor":"Single-State-Tree","text":"Single State Tree","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Swift-Rex uses a single state tree that represents the entire state of your application. This makes it easy to track changes and debug issues."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct AppState: StateType {","    \/\/ User state","    var user: User?","    var isAuthenticated: Bool = false","","    \/\/ UI state","    var isLoading: Bool = false","    var errorMessage: String? = nil","","    \/\/ Feature state","    var counter: CounterState = CounterState()","    var todo: TodoState = TodoState()","    var settings: SettingsState = SettingsState()","","    \/\/ App state","    var lastUpdated: Date = Date()","}"]},{"anchor":"Nested-State","text":"Nested State","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Break down your state into smaller, focused pieces:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct CounterState {","    var count: Int = 0","    var history: [Int] = []","}","","struct TodoState {","    var todos: [Todo] = []","    var filter: TodoFilter = .all","    var isLoading: Bool = false","}","","struct SettingsState {","    var theme: Theme = .light","    var notifications: Bool = true","    var language: Language = .english","}"]},{"anchor":"State-Updates","text":"State Updates","type":"heading","level":2},{"anchor":"Immutable-Updates","text":"Immutable Updates","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Always create new state rather than modifying existing state:","type":"text"}]},{"code":["\/\/ ❌ Wrong - Direct mutation","state.count += 1","","\/\/ ✅ Correct - Create new state","state.count = state.count + 1"],"syntax":"swift","type":"codeListing"},{"text":"Batch Updates","level":3,"type":"heading","anchor":"Batch-Updates"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When updating multiple properties, do it in a single action:"}]},{"code":["case .userLoggedIn(let user):","    state.user = user","    state.isAuthenticated = true","    state.errorMessage = nil","    state.lastUpdated = Date()","    return [.none]"],"syntax":"swift","type":"codeListing"},{"text":"State Normalization","level":2,"type":"heading","anchor":"State-Normalization"},{"text":"Normalized Data","level":3,"type":"heading","anchor":"Normalized-Data"},{"type":"paragraph","inlineContent":[{"text":"Store related data in a normalized structure for better performance:","type":"text"}]},{"code":["struct AppState: StateType {","    \/\/ Normalized entities","    var users: [String: User] = [:]","    var posts: [String: Post] = [:]","    var comments: [String: Comment] = [:]","","    \/\/ References","    var currentUserId: String?","    var selectedPostId: String?","","    \/\/ UI state","    var isLoading: Bool = false","    var errorMessage: String? = nil","}"],"syntax":"swift","type":"codeListing"},{"text":"Benefits of Normalization","level":3,"type":"heading","anchor":"Benefits-of-Normalization"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Performance"}],"type":"strong"},{"type":"text","text":": Faster lookups and updates"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Consistency"}]},{"text":": Single source of truth for each entity","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Memory"}]},{"type":"text","text":": Reduced memory usage"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Updates"}]},{"type":"text","text":": Easier to update related data"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"State Composition","level":2,"type":"heading","anchor":"State-Composition"},{"text":"Combining Reducers","level":3,"type":"heading","anchor":"Combining-Reducers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Split your reducer into smaller, focused reducers:"}]},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case let .counter(action):","            return counterReducer.reduce(state: &state.counter, action: action)","","        case let .todo(action):","            return todoReducer.reduce(state: &state.todo, action: action)","","        case let .settings(action):","            return settingsReducer.reduce(state: &state.settings, action: action)","","        case .userLoggedIn(let user):","            state.user = user","            state.isAuthenticated = true","            return [.none]","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Action Composition","level":3,"type":"heading","anchor":"Action-Composition"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use associated values to compose actions:"}]},{"code":["enum AppAction: ActionType {","    case counter(CounterAction)","    case todo(TodoAction)","    case settings(SettingsAction)","    case user(UserAction)","}","","enum CounterAction: ActionType {","    case increment","    case decrement","    case reset","}","","enum TodoAction: ActionType {","    case add(String)","    case remove(String)","    case toggle(String)","    case setFilter(TodoFilter)","}"],"syntax":"swift","type":"codeListing"},{"text":"State Persistence","level":2,"type":"heading","anchor":"State-Persistence"},{"text":"Saving State","level":3,"type":"heading","anchor":"Saving-State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Persist important state to disk:"}]},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .userLoggedIn(let user):","            state.user = user","            state.isAuthenticated = true","            return [","                Effect { emitter in","                    \/\/ Save user to disk","                    try await UserDefaults.standard.setValue(","                        user.id,","                        forKey: \"currentUserId\"","                    )","                    await emitter.send(.userSaved)","                }","            ]","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Loading State","level":3,"type":"heading","anchor":"Loading-State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Load persisted state on app launch:"}]},{"code":["struct AppReducer: Reducer {","    func reduce(state: inout AppState, action: AppAction) -> [Effect<AppAction>] {","        switch action {","        case .loadPersistedState:","            return [","                Effect { emitter in","                    if let userId = UserDefaults.standard.string(forKey: \"currentUserId\") {","                        let user = try await UserService.fetchUser(id: userId)","                        await emitter.send(.userLoaded(user))","                    }","                }","            ]","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"State Validation","level":2,"type":"heading","anchor":"State-Validation"},{"text":"Input Validation","level":3,"type":"heading","anchor":"Input-Validation"},{"type":"paragraph","inlineContent":[{"text":"Validate state changes in your reducer:","type":"text"}]},{"code":["case .setCount(let count):","    guard count >= 0 else {","        state.errorMessage = \"Count cannot be negative\"","        return [.none]","    }","    state.count = count","    state.lastUpdated = Date()","    return [.none]"],"syntax":"swift","type":"codeListing"},{"text":"State Constraints","level":3,"type":"heading","anchor":"State-Constraints"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Enforce business rules in your state:"}]},{"code":["struct AppState: StateType {","    var count: Int = 0 {","        didSet {","            \/\/ Ensure count never goes below 0","            if count < 0 {","                count = 0","            }","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Performance Optimization","level":2,"type":"heading","anchor":"Performance-Optimization"},{"text":"Selective Updates","level":3,"type":"heading","anchor":"Selective-Updates"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Only update what has changed:"}]},{"code":["case .updateUserProfile(let profile):","    \/\/ Only update if profile actually changed","    if state.user?.profile != profile {","        state.user?.profile = profile","        state.lastUpdated = Date()","    }","    return [.none]"],"syntax":"swift","type":"codeListing"},{"text":"Computed Properties","level":3,"type":"heading","anchor":"Computed-Properties"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use computed properties for derived state:"}]},{"code":["extension AppState {","    var completedTodos: [Todo] {","        todos.filter { $0.isCompleted }","    }","","    var incompleteTodos: [Todo] {","        todos.filter { !$0.isCompleted }","    }","","    var todoCount: Int {","        todos.count","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Best Practices","level":2,"type":"heading","anchor":"Best-Practices"},{"text":"1. Keep State Minimal","level":3,"type":"heading","anchor":"1-Keep-State-Minimal"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Only store what you need:"}]},{"code":["\/\/ ❌ Don't store derived data","struct AppState {","    var todos: [Todo] = []","    var completedTodos: [Todo] = [] \/\/ Redundant","}","","\/\/ ✅ Store only source data","struct AppState {","    var todos: [Todo] = []","}"],"syntax":"swift","type":"codeListing"},{"text":"2. Use Descriptive Names","level":3,"type":"heading","anchor":"2-Use-Descriptive-Names"},{"type":"paragraph","inlineContent":[{"text":"Make your state properties self-documenting:","type":"text"}]},{"code":["\/\/ ❌ Unclear","var flag: Bool = false","","\/\/ ✅ Clear","var isUserLoggedIn: Bool = false"],"syntax":"swift","type":"codeListing"},{"text":"3. Group Related State","level":3,"type":"heading","anchor":"3-Group-Related-State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Keep related properties together:"}]},{"code":["struct AppState {","    \/\/ Authentication","    var user: User?","    var isAuthenticated: Bool = false","    var authToken: String?","","    \/\/ UI State","    var isLoading: Bool = false","    var errorMessage: String? = nil","    var currentTab: Tab = .home","","    \/\/ Feature State","    var counter: CounterState = CounterState()","    var todo: TodoState = TodoState()","}"],"syntax":"swift","type":"codeListing"},{"text":"4. Handle Loading States","level":3,"type":"heading","anchor":"4-Handle-Loading-States"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always track loading states for async operations:"}]},{"code":["case .loadUser:","    state.isLoading = true","    state.errorMessage = nil","    return [","        Effect { emitter in","            let user = try await UserService.fetchUser()","            await emitter.send(.userLoaded(user))","        }","    ]"],"syntax":"swift","type":"codeListing"},{"text":"5. Error Handling","level":3,"type":"heading","anchor":"5-Error-Handling"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Provide meaningful error messages:"}]},{"code":["case .loadUserFailed(let error):","    state.isLoading = false","    state.errorMessage = \"Failed to load user: \\(error.localizedDescription)\"","    return [.none]"],"syntax":"swift","type":"codeListing"},{"text":"Next Steps","level":2,"type":"heading","anchor":"Next-Steps"},{"type":"paragraph","inlineContent":[{"text":"Now that you understand state management, explore:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/Rex\/documentation\/Rex\/Store"},{"text":" - Learn about the Store implementation","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","isActive":true,"type":"reference"},{"text":" - Understand Reducer patterns","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","type":"reference","isActive":true},{"type":"text","text":" - Handle side effects"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"doc:BestPractices"},{"type":"text","text":" - Advanced patterns and tips"}],"type":"paragraph"}]}],"type":"unorderedList"}],"kind":"content"}],"identifier":{"url":"doc:\/\/Rex\/documentation\/Rex\/StateManagement","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"minor":3,"major":0},"metadata":{"modules":[{"name":"Rex"}],"role":"article","title":"State Management","roleHeading":"Article"},"hierarchy":{"paths":[["doc:\/\/Rex\/documentation\/Rex"]]},"variants":[{"paths":["\/documentation\/rex\/statemanagement"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"article","sections":[],"abstract":[{"text":"Learn how to effectively manage application state with Swift-Rex.","type":"text"}],"references":{"doc://Rex/documentation/Rex/Store":{"identifier":"doc:\/\/Rex\/documentation\/Rex\/Store","url":"\/documentation\/rex\/store","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Store","kind":"identifier"}],"navigatorTitle":[{"text":"Store","kind":"identifier"}],"title":"Store","role":"symbol","kind":"symbol","abstract":[]},"doc://Rex/documentation/Rex":{"abstract":[],"identifier":"doc:\/\/Rex\/documentation\/Rex","type":"topic","kind":"symbol","url":"\/documentation\/rex","title":"Rex","role":"collection"},"doc://Rex/documentation/Rex/Reducer":{"type":"topic","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"identifier":"doc:\/\/Rex\/documentation\/Rex\/Reducer","kind":"symbol","abstract":[{"text":"A protocol that defines the core logic for transforming state based on actions.","type":"text"}],"title":"Reducer","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/rex\/reducer"},"doc://Rex/documentation/Rex/Effect":{"abstract":[{"text":"A struct that represents a side effect that can be executed by the store.","type":"text"}],"identifier":"doc:\/\/Rex\/documentation\/Rex\/Effect","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"type":"topic","title":"Effect","url":"\/documentation\/rex\/effect","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Effect","kind":"identifier"}]}}}